---
title: "Combine Datasets"
output:
  html_document:
    df_print: paged
    highlight: tango
    theme: united
    toc: yes
    toc_depth: 4
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Meta-analysis on differential expression data

## Read in DE data

```{r}
library(here)


dge_files <- list.files(
  path = here("results"),
  pattern = "dge.tsv",
  recursive = TRUE,
  full.names = TRUE
)

dre_files <- list.files(
  path = here("results"),
  pattern = "dre.tsv",
  recursive = TRUE,
  full.names = TRUE
)
```

## Read into single data.tables

```{r}
library(data.table)


dge <- setDT(vroom::vroom(dge_files,
  id = "fpath",
  delim = "\t",
  col_types = list(
    contrast = "c",
    feature_id = "c",
    logFC = "d",
    unshrunk.logFC = "d",
    logCPM = "d",
    PValue = "d",
    FDR = "d"
  )
))

dre <- setDT(vroom::vroom(dre_files,
  id = "fpath",
  delim = "\t",
  col_types = list(
    contrast = "c",
    feature_id = "c",
    logFC = "d",
    unshrunk.logFC = "d",
    logCPM = "d",
    PValue = "d",
    FDR = "d"
  )
))
```

## Clean and add variables

```{r}
# function for extracting the experiment name from the filepath
clean_fpath = function(s) { gsub("/data-files/", "", 
                            gsub("/results/", "", 
                            regmatches(s, 
                            regexpr("\\/results\\/.*\\/", s)))) 
}

# create an experiment variable
dge[, experiment := clean_fpath(fpath)]
dre[, experiment := clean_fpath(fpath)]

# combine the contrast and the experiment into a new column
# (used to differentiate same conditions in different experiments)
dge[, condition := paste(experiment, contrast, sep = ".")]
dre[, condition := paste(experiment, contrast, sep = ".")]

# Filter REs to be same sets (Satellites and Simple repeats were removed from most analyses)
dre <- dre[!feature_id %like% "Satellite|Simple_repeat|Unknown|Low_complexity"]

# write the results out after removing fpath column
dge[, fpath := NULL]
dre[, fpath := NULL]
fwrite(dge, here("results", "combined", "data-files", "dge-all-experiments.csv"))
fwrite(dre, here("results", "combined", "data-files", "dre-all-experiments.csv"))

# create an additional column based on the feature's ranking within each condition
dge[, rank := frank(logFC, ties.method = "random"), by = condition]
dre[, rank := frank(logFC, ties.method = "random"), by = condition]
dge[, max_rank := max(rank), by = condition]
dre[, max_rank := max(rank), by = condition]
dge[, norm_rank := (rank - 1) / (max_rank - 1), by = condition]
dre[, norm_rank := (rank - 1) / (max_rank - 1), by = condition]
```

## Write the unique conditions out for manual annotation

I need to annotate the drugs by class/type/ something so they can be 
differentiated better on plots.

**I will have to manually edit this file since its information is not readily
available when downloading the datasets from GEO**

```{r}
fwrite(unique(dge[, .(experiment, contrast)]), 
       file = here("doc", "raw-experiment-annotation.csv")
       )
```

## After manual editing, read in the contrast metadata

```{r}
metadata <- fread(here("doc", "experiment-annotation.csv"))
metadata[, id := paste(experiment, contrast, sep = ".")]

head(metadata)
```

## Cast DE values into matrices

```{r}
dge_lfc_mat <- as.matrix(dcast(dge[, .(feature_id, condition, logFC)],
  feature_id ~ condition,
  value.var = "logFC"
), rownames = "feature_id")

dre_lfc_mat <- as.matrix(dcast(dre[, .(feature_id, condition, logFC)],
  feature_id ~ condition,
  value.var = "logFC"
), rownames = "feature_id")

# repeat for FDR values
dge_fdr_mat <- as.matrix(dcast(dge[, .(feature_id, condition, FDR)],
  feature_id ~ condition,
  value.var = "FDR"
), rownames = "feature_id")

dre_fdr_mat <- as.matrix(dcast(dre[, .(feature_id, condition, FDR)],
  feature_id ~ condition,
  value.var = "FDR"
), rownames = "feature_id")

# repeat for normalized ranks
dge_rank_mat <- as.matrix(dcast(dge[, .(feature_id, condition, norm_rank)],
  feature_id ~ condition,
  value.var = "norm_rank"
), rownames = "feature_id")

dre_rank_mat <- as.matrix(dcast(dre[, .(feature_id, condition, norm_rank)],
  feature_id ~ condition,
  value.var = "norm_rank"
), rownames = "feature_id")
```

## Replace NA values after cast

LFC values that were NA get 0 for their logFC and FDR values that were NA get 1.
Ranks have been imputed with the median rank per condition. For normalized ranks
place NAs directly in the middle (0.5)

```{r}
dge_lfc_mat[is.na(dge_lfc_mat)] <- 0
dre_lfc_mat[is.na(dre_lfc_mat)] <- 0
dge_fdr_mat[is.na(dge_fdr_mat)] <- 1
dre_fdr_mat[is.na(dre_fdr_mat)] <- 1
dge_rank_mat[is.na(dge_rank_mat)] <- 0.5
dre_rank_mat[is.na(dre_rank_mat)] <- 0.5

# impute the median rank per column for NA values
# for (i in 1:ncol(dge_rank_mat)) {
#   imputed_val <- median(dge_rank_mat[, i], na.rm = TRUE)
#   dge_rank_mat[, i][is.na(dge_rank_mat[, i])] <- imputed_val
# }
# 
# for (i in 1:ncol(dre_rank_mat)) {
#   imputed_val <- median(dre_rank_mat[, i], na.rm = TRUE)
#   dre_rank_mat[, i][is.na(dre_rank_mat[, i])] <- imputed_val
# }
```

## Reorder metadata by matrix colnames

```{r}
metadata <- metadata[id %chin% colnames(dge_lfc_mat)][order(match(id, colnames(dge_lfc_mat)))]

# check if all rownames and colnames align
all(metadata$id == colnames(dre_lfc_mat))

# convert to data.frame with rownames for PCAtools
metadata <- data.frame(as.matrix(metadata, rownames = "id"))
```

## Combine into a SummarizedExperiment object

This will help with managing filtering the datasets

```{r message=FALSE, warning=FALSE}
library(SummarizedExperiment)


dge_se <- SummarizedExperiment(
  assays = list(lfc = dge_lfc_mat, fdr = dge_fdr_mat, rank = dge_rank_mat),
  colData = metadata)

dre_se <- SummarizedExperiment(
  assays = list(lfc = dre_lfc_mat, fdr = dre_lfc_mat, rank = dre_rank_mat),
  colData = metadata)

# save objects out to be read into interactive visualization
saveRDS(dge_se, here("results", "combined", "rds-files", "dge_se.rds"), compress = FALSE)
saveRDS(dre_se, here("results", "combined", "rds-files", "dre_se.rds"), compress = FALSE)
```
