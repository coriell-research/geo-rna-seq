---
title: "Combine Datasets"
output:
  html_document:
    df_print: paged
    highlight: tango
    theme: united
    toc: yes
    toc_depth: 4
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Meta-analysis on differential expression data

## Read in DE data

```{r}
library(here)

dge_files <- list.files(
  path = here("results"),
  pattern = "dge.tsv",
  recursive = TRUE,
  full.names = TRUE
)

dre_files <- list.files(
  path = here("results"),
  pattern = "dre.tsv",
  recursive = TRUE,
  full.names = TRUE
)
```

## Read into single data.tables

```{r}
library(data.table)


dge <- setDT(
  vroom::vroom(
    dge_files,
    id = "fpath",
    delim = "\t",
    col_types = list(
      contrast = "c",
      feature_id = "c",
      logFC = "d",
      unshrunk.logFC = "d",
      logCPM = "d",
      PValue = "d",
      FDR = "d")
  )
)

dre <- setDT(
  vroom::vroom(
    dre_files,
    id = "fpath",
    delim = "\t",
    col_types = list(
      contrast = "c",
      feature_id = "c",
      logFC = "d",
      unshrunk.logFC = "d",
      logCPM = "d",
      PValue = "d",
      FDR = "d")
  )
)
```

## Clean and add variables

```{r}
# function for extracting the experiment name from the filepath
clean_fpath <- function(s) { 
  gsub("/data-files/", "", 
  gsub("/results/", "", 
  regmatches(s, 
  regexpr("\\/results\\/.*\\/", s)))) 
}

# create an experiment variable by extracting project ID from path
dge[, experiment := clean_fpath(fpath)]
dre[, experiment := clean_fpath(fpath)]
dge[, fpath := NULL]
dre[, fpath := NULL]

# combine the contrast and the experiment into a new column
# (used to differentiate same conditions in different experiments)
dge[, id := paste(experiment, contrast, sep = ".")]
dre[, id := paste(experiment, contrast, sep = ".")]

# write the results out
fwrite(dge, here("results", "combined", "data-files", "dge-all-experiments.csv.gz"))
fwrite(dre, here("results", "combined", "data-files", "dre-all-experiments.csv.gz"))
```

## Write the unique conditions out for manual annotation

I need to annotate the drugs by class/type/ something so they can be 
differentiated better on plots.

**I will have to manually edit this file since its information is not readily
available when downloading the datasets from GEO**

```{r}
fwrite(unique(dge[, .(id, experiment, contrast)]), file = here("doc", "raw-experiment-annotation.csv"))
```

## Read in contrast matrices

the contrast matrices contain the group to contrast mappings. 

```{r}
contrasts <- list.files(
  path = here("results"),
  pattern = "contrast-matrix.rds",
  recursive = TRUE,
  full.names = TRUE
)

names(contrasts) <- regmatches(contrasts, regexpr("PRJNA[0-9]+", contrasts))
contrast_mats <- lapply(contrasts, readRDS)
contrast_dts <- lapply(contrast_mats, as.data.table, keep.rownames = "group")

# helper function for cleaning the contrast matrix dts
clean_contrast <- function(dt) {
  dt.m <- melt(dt, id.vars = "group", variable.name = "contrast", value.name = "present")
  dt.m[present != 0, .(contrast, group, var = ifelse(present == 1, "condition", "control"))]
}

contrast_dt <- rbindlist(lapply(contrast_dts, clean_contrast), idcol = "experiment")
head(contrast_dt)
```

## Read in design matrices

The design matrices contain the sample to group mapping.

```{r}
designs <- list.files(
  path = here("results"),
  pattern = "design.rds",
  recursive = TRUE,
  full.names = TRUE
)

names(designs) <- regmatches(designs, regexpr("PRJNA[0-9]+", designs))
design_mats <- lapply(designs, readRDS)
design_dts <- lapply(design_mats, as.data.table, keep.rownames = "sample_name")

# helper function for cleaning design matrix
clean_design <- function(dt) {
  dt.m <- melt(dt, id.vars = "sample_name", variable.name = "group", value.name = "present")
  dt.m[present == 1, .(sample_name, group)]
}

design_dt <- rbindlist(lapply(design_dts, clean_design), idcol = "experiment")

head(design_dt)
```

## Create ranking metrics

```{r}
# create an additional column based on the feature's ranking within each condition
dge[, rank := frank(logFC, ties.method = "random"), by = id]
dre[, rank := frank(logFC, ties.method = "random"), by = id]
dge[, max_rank := max(rank), by = id]
dre[, max_rank := max(rank), by = id]
dge[, norm_rank := (rank - 1) / (max_rank - 1), by = id]
dre[, norm_rank := (rank - 1) / (max_rank - 1), by = id]
```

## After manual editing, read in the contrast metadata

This file comes from the shared Google Doc

```{r}
metadata <- fread(here("doc", "metadata.csv"))
drugs <- fread(here("doc", "drugs.csv"))
cells <- fread(here("doc", "cells.csv"))

# left join drug info onto metadata
metadata <- merge.data.table(x = metadata, 
                             y = drugs,
                             by.x = "drug",
                             by.y = "drug",
                             all.x = TRUE,
                             all.y = FALSE)

# left join cell_info onto metadata
metadata <- merge.data.table(x = metadata,
                             y = cells,
                             by.x = "cell_line",
                             by.y = "cell_line",
                             all.x = TRUE,
                             all.y = FALSE)
```

## Cast DE values into matrices

```{r}
dge_lfc_mat <- as.matrix(dcast(dge[, .(feature_id, id, logFC)],
  feature_id ~ id,
  value.var = "logFC"
), rownames = "feature_id")

dre_lfc_mat <- as.matrix(dcast(dre[, .(feature_id, id, logFC)],
  feature_id ~ id,
  value.var = "logFC"
), rownames = "feature_id")

# repeat for FDR values
dge_fdr_mat <- as.matrix(dcast(dge[, .(feature_id, id, FDR)],
  feature_id ~ id,
  value.var = "FDR"
), rownames = "feature_id")

dre_fdr_mat <- as.matrix(dcast(dre[, .(feature_id, id, FDR)],
  feature_id ~ id,
  value.var = "FDR"
), rownames = "feature_id")

# repeat for normalized ranks
dge_rank_mat <- as.matrix(dcast(dge[, .(feature_id, id, norm_rank)],
  feature_id ~ id,
  value.var = "norm_rank"
), rownames = "feature_id")

dre_rank_mat <- as.matrix(dcast(dre[, .(feature_id, id, norm_rank)],
  feature_id ~ id,
  value.var = "norm_rank"
), rownames = "feature_id")
```

## Replace NA values after cast

LFC values that were NA get 0 for their logFC and FDR values that were NA get 1.
Ranks have been imputed with the median rank per condition. For normalized ranks
place NAs directly in the middle (0.5)

```{r}
dge_lfc_mat[is.na(dge_lfc_mat)] <- 0
dre_lfc_mat[is.na(dre_lfc_mat)] <- 0
dge_fdr_mat[is.na(dge_fdr_mat)] <- 1
dre_fdr_mat[is.na(dre_fdr_mat)] <- 1
dge_rank_mat[is.na(dge_rank_mat)] <- 0.5
dre_rank_mat[is.na(dre_rank_mat)] <- 0.5

# impute the median rank per column for NA values
# for (i in 1:ncol(dge_rank_mat)) {
#   imputed_val <- median(dge_rank_mat[, i], na.rm = TRUE)
#   dge_rank_mat[, i][is.na(dge_rank_mat[, i])] <- imputed_val
# }
# 
# for (i in 1:ncol(dre_rank_mat)) {
#   imputed_val <- median(dre_rank_mat[, i], na.rm = TRUE)
#   dre_rank_mat[, i][is.na(dre_rank_mat[, i])] <- imputed_val
# }
```

## Reorder metadata by matrix colnames

```{r}
# convert to data.frame with rownames for PCAtools
metadata <- data.frame(as.matrix(metadata, rownames = "id"))

# reorder metadata to match col order of matrices
metadata <- metadata[colnames(dge_lfc_mat), ]

# double-check
all(rownames(metadata) == colnames(dge_lfc_mat))
```

## Combine into a SummarizedExperiment object

This will help with managing filtering the datasets

```{r message=FALSE, warning=FALSE}
library(SummarizedExperiment)


dge_se <- SummarizedExperiment(
  assays = list(lfc = dge_lfc_mat, fdr = dge_fdr_mat, rank = dge_rank_mat),
  colData = metadata)

dre_se <- SummarizedExperiment(
  assays = list(lfc = dre_lfc_mat, fdr = dre_lfc_mat, rank = dre_rank_mat),
  colData = metadata)

# save objects out to be read into interactive visualization
saveRDS(dge_se, here("results", "combined", "rds-files", "dge_se.rds"), compress = FALSE)
saveRDS(dre_se, here("results", "combined", "rds-files", "dre_se.rds"), compress = FALSE)
```
